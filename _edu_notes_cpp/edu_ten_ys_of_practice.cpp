Десять лет я пишу на С++.

Первые пять лет моей задачей было писать эффективный код для компьютерных игр, потом основным требованием была стабильность, так как речь шла об автоматизации промышленных объектов. Я бы хотел поделиться своим личным опытом и практическими наработками, которые помогут создавать эффективные и в то же время стабильно работающие программы.

Материал разбит на части, от самых общих практических правил, интересных начинающим, до конкретных вопросов, актуальных опытным программистам.
В первой части я на практике дам свой ответ на самые базовые вопросы. Как вообще писать программу, в особенности — сложную программу? Что следует сделать в самом начале, чтобы потом не переделывать с нуля? Как создать оптимальную структуру программы?

Итак, коллеги, мы пишем на С++. Как правило, это значит что наши программы сложны. Некоторые — очень сложны. Чтобы программа работала как нужно мне, её создателю, требуется держать в уме то как она работает, вплоть до мельчайших деталей. Это необходимое условие, так как всё что не удалось полностью продумать — это гарантированные баги.

Удержать в голове всю картину на всех уровнях абстракции одновременно, невозможно. Поэтому я делю сложную систему на куски попроще. Каждый из них хорошо понятен и очевиден, как гвоздь. Всё что сложнее, собирается из более простых элементов. Очевидно? Конечно! Но выполнять это правило нужно неукоснительно.

Если я пишу программу, которая использует неотработанную технологию или элемент, я сначала делаю этюд. Небольшую консольную программку, которая содержит в себе нужный кусок. Этот этюд я мучаю до посинения, пока чётко не пойму как и чего работает, какие ограничения на вводные данные, какие особенности и подводные камни. Да, у меня целая директория из нескольких сотен этюдов. Каждый в конечном итоге доводится до независимого куска кода (чаще всего, класса или связки классов), который я вставляю в программу как батарейку: вытащил старую версию — воткнул новую.

«Склейка» элементов иногда представляет собой довольно сложный механизм сама по себе, а потому требует отдельного этюда. Но этого мало, когда речь идёт о сложных механизмах. Все сложные алгоритмы я записываю на бумагу. Невозможно написать на С++ то, что не можешь описать простым русским языком. Когда описываешь что-то словами, мозг натыкается на подводные камни и нестыковки. Они становятся видны в самом начале, а не в конце, когда код уже написан. Сам текст должен быть отшлифован, тонкие места — упомянуты. Ещё плюс: можно вернуться к проекту через год и не тратить недели на вспоминание почему это сделано именно так.
Для каждого заказчика я завёл по тетради. В них — все нетривиальные моменты, от создания реалистичной пены вокруг парусного фрегата, до вычисления оптимальных траекторий подъёмных кранов на узком пятачке вокруг раскалённых металлов и кислот. Если мне встречается похожая задача, я просто заглядываю в тетрадь. Там, среди перечёркнутых текстов и схемок, за 10-15 минут я воспроизвожу в памяти весь ход создания алгоритма со всеми его особенностями. Как правило, задачи не повторяются полностью, но какая-то идея оказывается нужной через три-четыре года.

Очевидно? Отлично! Чуть усложним и заглянем внутрь элементов, о которых я говорил выше…

С++ очень прост в том смысле, что классы С++ зачастую повторяют описание объектов реального мира (не в смысле прямого копирования, а в смысле названий, частично — функциональности и взаимоотношений, кроме того, в С++ бывают синтетические вспомогательные классы). Когда объект реального мира является или содержит другой объект реального мира (только один), в С++ применяется наследование классов. Если объект-потомок может содержать нескольких однотипных — применяем включение объектов в класс потомка. Однотипное поведение классов выделяем в отдельный класс (который я буду называть классом подмешивания). Всё это отлично расписано у Алена Голуба [2], так что не буду повторять мастерски написанный текст. Скажу только что это простое мнемоническое правило следует запомнить и применять на автомате.

Гораздо менее канонический вопрос в распределении прав доступа к членам и функциям-членам класса. Все конечно знают про инкапсуляцию, все читали книжки. Что со всем этим делать на практике?

На практике происходит следующее. Я делаю класс Бункер, который описывает реальный бункер, к которому подключены датчики. Бункеры объединяются в цеха, всё это выводится в красивый интерфейс, как-то взаимодействует между собой и с человеком.
Спрашивается, сколько внутренней информации о Бункере я открыл другим классам? Отвечаю: вообще ничего. Понимаете? Все члены класса — приватные. Никто извне не должен знать что у класса внутри. Причина ясна: поменял что-то в классе — и цепочка изменений потянулась по всему коду, который за секунду до этого был чист и отлажен как швейцарские часы.

Итак, Бункер не выдаёт наружу подробности своей реализации. При этом, он сам выводит себя в интерфейс, сам обрабатывает нажатия на свои контролы, сам выполняет всю работу, которая требует знания о том, как он устроен. Наружу открываются функции-члены, которые просят класс выполнить ту или иную работу: выведи себя в интерфейс, обработай нажатие мышки, сохрани себя в XML и т.д.

Вы наверное спросите: может не стоило так усложнять, почему бы не сделать классы более открытыми и дружелюбными? «Ни в коем случае» — отвечу я,- и вот почему.
Проходит два месяца работы программы, и заказчик просит меня сделать удалённое управление бункером. Потом удалённое управление требуется по разным каналам связи — от Интернет до сотовой сети и последовательного порта, причём каналы связи должны дублироваться. Время идёт, программа работает, и постепенно выясняется необходимость в удалённой синхронизации журналов действий операторов. А ещё через пару месяцев я выясняю что необходимо делать инкрементальную синхронизацию состояния бункеров и журнала при плохой связи (например, зашумлённый RS-485 или Wi-Fi на больших расстояниях).

Что я сделал? Я усложнил класс Бункер, который теперь работает либо локально, либо удалённо. Добавил ещё кое-какой код, который подхватывает настройки GSM/Ethernet/RS-232. И главное: всё остальное осталось как было. Все месяцы работы по тонкой настройке алгоритмов управления остались со мной! То же самое относилось и к журналу, и ко всему остальному.
Если бы я вынес наружу хотя бы что-то из внутренней кухни Бункера, я даже боюсь представить сколько всего мне пришлось бы переписывать из 250 кБ управляющего кода.

Ещё раз повторю важный момент: структура программы на С++ отличается от С с точностью до наоборот. Там у нас были структуры и общие переменные. Здесь у нас объекты, которые суть чёрные ящики. Каждый объект — сам себе жнец, швец, на дуде игрец.
С другой стороны, сам код класса должен быть простым. Если требуется сложный функционал, я реализую его включением в класс внутренних объектов-помощников, либо использую классы подмешивания (но более осторожно, поскольку наследование является более сильной формой сцепления, чем включение).

Напоминаю, что get/set доступ — это чуть более завуалированный вариант открытого члена класса. С этим подходом нам не по пути.

Правильный способ взаимодействия с объектом — попросить его сделать то или иное действие.
Вместо того чтобы запрашивать данные, просим объект сделать нужное действие самостоятельно. Это необходимое условие стабильности больших проектов на С++. В некоторых случаях реализация какого-то действия — просто вернуть значение члена класса (то самое исключение, которое подтверждает правило).

И последнее. Любая структура имеет ограниченный потенциал роста. Возможно, заказчик затребует такие глобальные изменения, что потребуется менять интерфейс взаимодействия между классами. Более того, может потребоваться менять структуру классов. Но и это ещё не всё: есть объективные временные рамки на обкатку программы, в ходе которых становится очевидной необходимость создать новую структуру классов.

Хочу успокоить: всё это совершенно нормально. Программой пользуются — значит программа живёт, а значит меняется и развивается её структура. Прежде чем программа станет действительно хорошей, её, почти наверняка, придётся несколько раз переписать (мои самые серьёзные программы, как правило, переписываются дважды или трижды). Такая программа обладает отличным потенциалом роста, она больше не страдает «детскими болезнями» и, как правило, работает как те самые швейцарские часы. А все наработки из прошлой версии переносятся тем проще, чем более изолированными были изначальные классы.

Литература:
Бьёрн Страуструп. Язык программирования С++.
Ален И. Голуб «Верёвка достаточной длины чтобы… выстрелить себе в ногу».

В следующей части: прощаюсь с проблемами new/delete, избавляюсь от необходимости в умных указателях и мусоросборщиках, заменяя их на более простую и естественную методику работы с ресурсами.


2.

Здравствуйте. Я планировал написать большую статью об управлении ресурсами в С++.
Но на практике, тема эта такая сложная и многогранная, что я хочу остановиться на определённой методике, которой пользуюсь сам. Данная методика не является спасением на все случаи жизни, но экономит много времени и нервов при работе с объектами. При этом, не является широко известной.

Подход этот называется «everything belongs somewhere». О нём я впервые узнал, пересаживаясь c Qt на замечательный фреймворк U++, созданный группой авторов во главе с Миреком Фидлером (Mirek Fidler). Произошло это около пяти лет назад, так что я поделюсь не только самим методом, но и практическими советами исходя из опыта его применения.

Вкратце, суть методики можно описать фразой: «всё кому-то принадлежит».
Класс-хозяин несёт в себе все ресурсы, необходимые для полноценной работы. Например:
Объекты, описывающие узлы бункера, включаются в класс бункера. Объекты-помощники, а также объекты с данными для класса сложных расчётов, включаются в него. И так далее.
Исключение составят несколько глобальных переменных, представляющих собой самые основные объекты. В некотором роде, и они являются членами безымянного глобального «класса».

Теперь мы говорим следующее:
объект определяется в виде обычного члена класса, либо помещается в контейнер, являющийся членом класса
право владения объектом не передаётся

Заметьте: определяется не в виде указателя, не в виде ссылки, а обычным образом. Мы можем взять указатель на объект, передавать его куда-то, но только для использования. То есть сторонний код не может сделать delete или new нашему указателю. Им управляет только класс-хозяин.


Что делать, если объект будет создан не сразу?
В этом случае, понадобится либо одиночный контейнер (вроде unique_ptr), либо контейнер-массив. Главная их функция — автоматическое удаление объекта в деструкторе. Всё!

А вот здесь остановимся и подумаем, что же мы получили.

1. Мы избавились от ручных вызовов new/delete. Причём избавились так хорошо, что даже в случае выбросов исключения, а также любых других ситуаций, наши ресурсы будут гарантированно удалены.

2. Мы получили очень хорошую автоматическую систему управления ресурсами, учитывающую семантику программы.
Например, у нас есть несколько окон. Какое-то из окон по ходу работы программы уничтожается. При этом удаляются все его ресурсы. Мы точно контролируем момент удаления ресурса, это очень важно.
Мы не полагаемся на мусоросборщик. Мы точно знаем, что в нужный момент память будет освобождена.

Согласитесь, детерминированное управление ресурсами — это большой контраст с возможностью в любой момент наткнуться на процедуру удаления мусора (скажем, пока играется видео, или нужно остановить сервопривод), либо возможностью тряски мусоросборщика в тщетных попытках удалить ресурс в требуемый момент.

3. Когда объект-хозяин выдаёт указатель на свой член, он может гарантировать, что по этому указателю существует нужный объект нужного класса. Когда мы пользуемся таким указателем, мы работаем в области видимости объекта-хозяина. А значит нам гарантируется валидность указателя. Понимаете? Время жизни объекта по указателю гарантируется самим компилятором, который на этапе компиляции проверит видимость объекта-хозяина.
Это же практически мечта: эффективно работать через указатели, валидность которых проверена ещё на этапе компиляции! И всё это — без накладных расходов.

4. Наконец, когда мы поняли, что у нас вопросы создания, удаления и валидности доступа решены без накладных расходов, мы приходим к тому, что «сложные» умные указатели со счётчиком ссылок и более сложными механизмами внутри, становятся попросту не нужны.

Мы накладываем ограничения на структуру программы. Проводим более тщательное проектирование и планирование. И за счёт этого, мы приходим к гораздо более детерминированной работе с ресурсами без накладных расходов. Отказываемся от всех явных вызовов delete, большинства явных вызовов new и контейнеров со счётчиками ссылок — и уходим от всех проблем, им сопутствующих.

Такая программа качественно отличается от программы на С. Здесь мы скрываем из области видимости всё, что не относится к текущему функционалу. Здесь, чаще всего, у нас нет десятков глобальных переменных или объектов и сотни глобальных функций, их обслуживающих. Вместо этого, глобальных переменных-объектов, как правило, несколько. Каждый из них является достаточно автономным и реализует достаточно большой функционал, реализуемый включаемыми объектами. В прошлой статье я упоминал, что эти объекты желательно делать закрытыми членами, так как это минимизирует сцепления внутри иерархии классов.

Вот, если коротко, в чём заключается подход.

Теперь о подводных камнях.
Прежде всего, это может значить совершенно другой стиль декомпозиции на классы, по сравнению с мейнстримовым подходом, активно использующим умные указатели со счётчиком ссылок. Зачастую, наложить указанные ограничения очень непросто, и подход с умными указателями кажется более привлекательным. Но, как показывает практика разработчиков фреймворка и практика автора статьи — лучше постараться, и сделать всё в соответствии с подходом. Эти усилия в десятки раз окупятся при отладке и поддержке программы.

Во-вторых, при активном использовании, у вас появится необходимость в хороших, быстрых контейнерах, которые не будут накладывать на классы элементов ограничения в виде операторов копирования. Примитивная реализация таких контейнеров будет довольно простой. Эффективная реализация — вопрос отдельной статьи. Потому что для эффективной работы нужна реализация передачи (оно же разрушающее копирование), а также переноса (оно же сверхбыстрое копирование) — если будет интересно, эти темы будут обсуждены далее.

В-третьих, из этих правил может вытекать следующая стратегия работы с GUI. Контролы принадлежат их логическому владельцу (не окну, а тому, кто хранит в них свою семантику, ведь он её владелец). В этом смысле, у вас есть два выбора: апологеты MVC могут всё оставить как есть. Либо, вы можете воспользоваться таким подходом, который, как показывает практика, зачастую себя окупает. Разумеется, это не священная корова, а наоборот — подлежит критическому осмыслению и проверке на практике.

Пожалуйста, указывайте на неточности, пробуйте, критикуйте, применяйте. Буду рад любым откликам.

Литература:
1. U++ overview.

В следующей части предполагается обсудить передачу (pick beaviour) и перенос (moveable) объектов. Будет показано, как эти возможности дают существенный прирост скорости работы с объектами. А контейнеры на их основе в 4-5 раз быстрее STL.
После чего можно будет переходить к турбо-скоростной и очень безопасной реализации многопоточности, вдохновлённой Эрлангом.


