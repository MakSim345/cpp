Smart pointers для начинающих

Эта небольшая статья в первую очередь предназначена для начинающих C++ программистов, которые либо слышали об умных указателях, но боялись их применять, либо они устали следить за new-delete.


Итак, программисты С++ знают, что память нужно освобождать. Желательно всегда. И они знают, что если где-то пишется new, обязательно должен быть соответствующий delete. Но ручные манипуляции с памятью могут быть чреваты, например, следующими ошибками:

    - утечки памяти;
    - разыменовывание нулевого указателя, либо обращение к неициализированной области памяти;
    - удаление уже удаленного объекта;

Утечка в принципе не так критична, если программа не работает 24/7, либо код, ее вызывающий, не находится в цикле. При разыменовывании нулевого указателя мы гарантированно получим сегфолт, осталось только найти тот случай когда он становится нулевым (вы же понимаете о чем я). При повторном удалении может случиться вообще все, что угодно. Обычно (хотя может быть и не всегда), если вам выделяется блок памяти, то где-то с ним по соседству лежит значение, определяющее количество выделенной памяти. Детали зависят от реализациии, но допустим, что вы выделили 1 кб памяти начиная с некоторого адреса. Тогда по предыдущему адресу будет храниться число 1024, таким образом станет возможным при вызове delete удалить ровно 1024 байт памяти, не больше и не меньше. При первом вызове delete все отлично, при втором вы потрете не те данные. Чтобы всего этого избежать, либо уменьшить вероятность появления подобного рода ошибок, и были придуманы умные указатели.

Введение

Существует техника управления ресурсами посредством локальных объектов, называемая RAII. То есть, при получении какого-либо ресурса, его инициализируют в конструкторе, а, поработав с ним в функции, корректно освобождают в деструкторе. Ресурсом может быть что угодно, к примеру файл, сетевое соединение, а в нашем случае блок памяти. Вот простейший пример:

        class VideoBuffer 
        {
            int *myPixels;
        public:
            VideoBuffer() 
            {
                pixels = new int[640 * 480];
            }
            void makeFrame() 
            { /* работаем с растром */ }

            ~VideoBuffer() 
            {
                delete [] pixels;
            }
        };
        int game() 
        {
            VideoBuffer screen;
            screen.makeFrame();
        }


Это удобно: по выходу из функции нам не нужно заботиться об освобождении буфера, так как для объекта screen вызовется деструктор, который в свою очередь освободит инкапсулированный в себе массив пикселей. Конечно, можно написать и так:

        int game() 
        {
            int *myPixels = new int[640 * 480];
            // работаем
            delete [] pixels;
        }


В принципе, никакой разницы, но представим себе такой код:

        int game() 
        {
            int *myPixels = new int[640 * 480];
            // работаем
            if (someCondition)
                return 1;        
            // работаем дальше    
            if (someCondition)
                return 4;        
            // поработали
            delete [] pixels;
        }

Придется в каждой ветке выхода из функции писать delete [], либо вызывать какие-либо дополнительные функции деинициализации. А если выделений памяти много, либо они происходят в разных частях функции? Уследить за всем этим будет все сложнее и сложнее. Подобная ситуация возникает, если мы в середине функции бросаем исключение: гарантируется, что объекты на стеке будут уничтожены, но с кучей проблема остается открытой.
Ок, будем использовать RAII, в конструкторах инициализировать память, в деструкторе освобождать. И пусть поля нашего класса будут указателями на участки динамической памяти:

        class Foo 
        {
            int *data1;
            double *data2;
            char *data3;
        
            public:
            Foo() 
            {
                data1 = new int(5);
                ...
            }
            ~Foo() 
            {
                delete data1;
                ...
            }
        }


Теперь представьте, что полей не 3, а 30, а значит в деструкторе придется для всех них вызывать delete. А если мы второпях добавим новое поле, но забудем его убить в деструкторе, то последствия будут негативными. В итоге получается класс, нагруженный операциями выделения\освобождения памяти, да еще и непонятно, все ли было правильно удалено.
Поэтому предлагается использовать умные указатели: это объекты, которые хранят указатели на динамически аллоцированные участки памяти произвольного типа. Причем они автоматически очищают память по выходу из области видимости.
Сначала рассмотрим то, как они выглядят в С++, затем перейдем к обзору некоторых распространенных типов умных указателей.
Простейший smart pointer

        // Класс нашего умного указателя
        template <typename T>
        class smart_pointer 
        {
            T *m_obj;
        public:
            // Отдаем ему во владение некий объект
            smart_pointer(T *obj)
                : m_obj(obj)
            { }
            // По выходу из области видимости этот объект мы уничтожим
            ~smart_pointer() 
            {
                delete m_obj;
            }
            // Перегруженные операторы
            // Селектор. Позволяет обращаться к данным типа T посредством "стрелочки"
            T* operator->() { return m_obj; }
            // С помощью такого оператора мы можем разыменовать указатель и получить ссылку на
            // объект, который он хранит
            T& operator* () { return *m_obj; }
        }
        
        int test 
        {
            // Отдаем myClass во владение умному указателю
            smart_pointer<MyClass> pMyClass(new MyClass(/*params*/);    
            // Обращаемся к методу класса MyClass посредством селектора
            pMyClass->something();    
            // Допустим, что для нашего класса есть функция вывода его в ostream
            // Эта функция одним из параметров обычно получает ссылку на объект,
            // который должен быть выведен на экран
            std::cout << *pMyClass << std::endl;    
            // по выходу из скоупа объект MyClass будет удален
         }

Понятно, что наш смарт пойнтер не лишен недостатков (например, как хранить в нем массив?), но он в полной мере реализует идиому RAII. Он ведет себя так же, как и обычный указатель (благодаря перегруженным операторам), причем нам не нужно заботиться об освобождении памяти: все будет сделано автоматически. По желанию к перегруженным операторам можно добавить const, гарантировав неизменность данных, на которые ссылается указатель.
Теперь, если вы поняли, что получаете определенные преимущества, при использовании таких указателей, рассмотрим их конкретные реализации. Если вам не нравится эта идея, то все равно, попробуйте использовать их в какой-нибудь своей маленькой программке, уверяю, вам должно понравиться.
Итак, наши смарт-пойнтеры:

    boost::scoped_ptr
    std::auto_ptr
    std::tr1::shared_ptr (он же std::shared_ptr в C++11, либо boost::shared_ptr из boost)

    boost::scoped_ptr

Он находится в библиотеке boost.
Реализация простая и понятная, практически идентичная нашей, за несколькими исключениями, одно из них: этот пойнтер не может быть скопирован (то есть у него приватный конструктор копирования и оператор присваивания). Поясню на примере:

        #include <boost/scoped_ptr.hpp>
        int test() 
        {
            boost::scoped_ptr<int> p1(new int(6));
            boost::scoped_ptr<int> p2(new int(1));    
            p1 = p2; // Нельзя!
        }


Оно и понятно, если бы было разрешено присваивание, то и p1 и p2 будут указывать на одну и ту же область памяти. А по выходу из функции оба удалятся. Что будет? Никто не знает. Соответственно, этот пойнтер нельзя передавать и в функции.
Тогда зачем он нужен? Советую применять его как указатель-обертка для каких-либо данных, которые выделяются динамически в начале функции и удаляются в конце, чтобы избавить себя от головной боли по поводу корректной очистки ресурсов.

Подробное описание здесь.
std::auto_ptr

Чуть-чуть улучшенный вариант предыдущего, к тому же он есть в стандартной библиотеке (хотя в C++11 вроде как deprecated). У него есть оператор присваивания и конструктор-копировщик, но работают они несколько необычно.
Поясняю:

        #include <memory>
        int test() 
        {
            std::auto_ptr<MyObject> p1(new MyObject);
            std::auto_ptr<MyObject> p2;    
            p2 = p1;
        }


Теперь при присваивании в p2 будет лежать указатель на MyObject (который мы создавали для p1), а в p1 не будет ничего. То есть p1 теперь обнулен. Это так называемая семантика перемещения. Кстати, оператор копирования поступает таким же образом.
Зачем это нужно? Ну например у вас есть функция, которая должна создавать какой-то объект:

        std::auto_ptr<MyObject> giveMeMyObject();

Это означает, что функция создает новый объект типа MyObject и отдает его вам в распоряжение. Понятней станет, если эта функция сама является членом класса (допустим Factory): вы уверены, что этот класс (Factory) не хранит в себе еще один указатель на новый объект. Объект ваш и указатель на него один.

В силу такой необычной семантики auto_ptr нельзя использовать в контейнерах STL. Но у нас есть shared_ptr.
    std::shared_ptr (С++11)

Умный указатель с подсчетом ссылок. Что это значит. Это значит, что где-то есть некая переменная, которая хранит количество указателей, которые ссылаются на объект. Если эта переменная становится равной нулю, то объект уничтожается. Счетчик инкрементируется при каждом вызове либо оператора копирования либо оператора присваивания. Так же у shared_ptr есть оператор приведения к bool, что в итоге дает нам привычный синтаксис указателей, не заботясь об освобождении памяти.

        #include <memory> // либо <tr1/memory> для компиляторов, еще не поддерживающих C++11
        #include <iostream>
        int test() 
        {
            std::shared_ptr<MyObject> p1(new MyObject);
            std::shared_ptr<MyObject> p2;    
            p2 = p1;    
            if (p2)
            {
                std::cout << "Hello, world!\n";
            }
        }

Теперь и p2 и p1 указывают на один объект, а счетчик ссылок равен 2, По выходу из скоупа счетчик обнуляется, и объект уничтожается. Мы можем передавать этот указатель в функцию:

        int test(std::shared_ptr<MyObject> p1) 
        {
            // делаем что-то
        }

Заметьте, если вы передаете указатель по ссылке, то счетчик не будет увеличен. Вы должны быть уверены, что объект MyObject будет жив, пока будет выполняться функция test.

Итак, smart pointers это хорошо, но есть и минусы.
Во-первых это небольшой оверхед, но я думаю у вас найдется несколько тактов процессора ради такого удобства.
Во-вторых это boiler-plate, например

        std::tr1::shared_ptr<MyNamespace::Object> ptr = std::tr1::shared_ptr<MyNamespace::Object>(new MyNamespace::Object(param1, param2, param3))

Это частично можно решить при помощи дефайнов, допустим:

        #define sptr(T) std::tr1::shared_ptr<T>

Либо при помощи typedef.

В-третьих, существует проблема циклических ссылок. Рассматривать ее здесь не буду, чтобы не увеличивать статью. Так же остались нерассмотренными boost::weak_ptr, boost::intrusive_ptr и указатели для массивов.

Кстати, smart pointers достаточно хорошо описаны у Джеффа Элджера в книге "С++ for real programmers".

=============================================================
Шпаргалка по использованию умных указателей в C++
26 февраля 2018

Благодаря наличию исключений, язык C++ позволяет разделить основную логику приложения и обработку ошибок, не мешая их в одну кучу. Что есть очень хорошо. Однако теперь по коду нельзя с уверенностью сказать, где может быть прервано его исполнение. Отсюда возникает опасность утечки ресурсов. Проблема эта решается при помощи деструкторов и идиомы RAII. Впрочем, придерживаться этой идиомы становится проблематично при использовании указателей. Особенно при использовании их не как членов класса, а просто как переменных в методах. На наше с вами счастье, в стандартной библиотеке языка есть умные указатели (smart pointers), придуманные именно для этого случая. Поскольку на C++ я пишу не регулярно, то иногда забываю некоторые нюансы использования умных указателей, в связи с чем решил вот набросать небольшую шпаргалку.

Важно! 
В старых книжках и статьях можно встретить упоминание auto_ptr. Этот тип умных указателей появился в C++, когда в языке еще не было move semantics. Из-за этого использование auto_ptr порой может приводить к трудным в обнаружении ошибкам. В стандарте C++17 auto_ptr был удален. Другими словами, все, что вы должны знать об auto_ptr — это то, что его не должно быть в современном коде. Вместо него всегда используйте unique_ptr.

1. unique_ptr
Шаблонный класс unique_ptr представляет собой уникальный указатель на объект. Указатель нельзя копировать, но можно передавать владение им с помощью std::move. При уничтожении указателя автоматически вызывается деструктор объекта, на который он указывает.

Создается unique_ptr так:

std::unique_ptr<SomeClass> unq(new SomeClass(/* ctor args */));

… но обычно используют шаблон make_unique, так короче:

auto unq = std::make_unique<SomeClass>(/* ctor args */);

Класс unique_ptr перегружает оператор ->, что позволяет обращаться к полям класса и вызывать его методы, словно мы работаем с обычным указателем:

unq->sayHello();

Как уже отмечалось, unique_ptr запрещено копировать:

// will not compile!
auto cpy = unq;

Однако владение им можно передать при помощи std::move, например:

auto mov = std::move(unq);
// unq is invalid now!
mov->sayHello();

Плюс к этому, мы всегда можем получать из unique_ptr обычный указатель на объект:

SomeClass* ptr = mov.get();
ptr->sayHello();

… хотя это и является code smell. Кроме того, ничто не мешает создавать ссылки (reference) на unique_ptr:

auto& ref = mov;
ref->sayHello();

То есть, в этом случае мы как бы не отнимаем владение объектом, а ненадолго одалживаем его, обращаясь к нему через все тот же умный указатель.

Интересно, что unique_ptr позволяет указать функцию, которую он будет вызывать вместо деструктора, так называемый custom deleter. Это позволяет использовать unique_ptr с ресурсами, возвращаемых из библиотек для языка C, и даже реализовать аналог defer из языка Go:

/* g++ custom-deleter.cpp -o custom-deleter */

#include <memory>
#include <functional>
#include <iostream>
#include <stdio.h>

template<typename T>
using auto_cleanup = std::unique_ptr<T,std::function<void(T*)>>;

static char dummy[] = "";

#define _DEFER_CAT_(a,b) a##b
#define _DEFER_NAME_(a,b) _DEFER_CAT_(a,b)
#define defer(...) \
  auto _DEFER_NAME_(_defer_,__LINE__) = \
    auto_cleanup<char>(dummy, [&](char*) { __VA_ARGS__; });

int main() 
{
    auto_cleanup<FILE> f(
        fopen("test.txt", "w"),
        [](FILE* f) { fclose(f); }
    );

    defer( std::cout << "Bye #1" << std::endl );
    defer( std::cout << "Bye #2" << std::endl );

    fwrite("Hello!\n", 7, 1, f.get());
}

Заметьте, что в макросе "defer" нам пришлось передать в unique_ptr фиктивный указатель. Если бы мы передали nullptr, custom deleter не был бы вызван.

Важно! 
Если в умном указателе вы держите указать на массив объектов, то обязаны указать custom deleter, вызывающий для этого массива delete[] вместо delete. Если этого не сделать, будет освобожден только первый объект из массива, остальные же утекут.

2. shared_ptr и weak_ptr

Класс shared_ptr является указатем на объект, которым владеет сразу несколько объектов. Указатель можно как перемещать, так и копировать. Число существующих указателей отслеживается при помощи счетчика ссылок. Когда счетчик ссылок обнуляется, вызывается деструктор объекта. Сам по себе shared_ptr является thread-safe, но он не делает магическим образом thread-safe объект, на который ссылается. То есть, если доступ к объекту может осуществляться из нескольких потоков, вы должны не забыть предусмотреть в нем мьютексы или что-то такое.

Для создания shared_ptr обычно используется шаблон "make_shared":

auto ptr = std::make_shared<SomeClass>(/* ctor args */);

В остальном работа с ним мало отличается от работы с unique_ptr, за тем исключением, что shared_ptr можно смело копировать.

Интересные грабли при использовании shared_ptr заключается в том, что с его помощью можно создать циклические ссылки. Например, есть два объекта. Первый ссылается при помощи shared_ptr на второй, а второй — на первый. Даже если ни на один из объектов нет других ссылок, счетчики ссылок никогда не обнулятся, и объекты никогда не будут уничтожены.

Эта проблема обходится при помощи weak_ptr, так называемого слабого указателя. Класс weak_ptr похож на shared_ptr, но не участвует в подсчете ссылок. Также у weak_ptr есть метод lock(), возвращающий временный shared_ptr на объект. Пример использования:

#include <memory>
#include <iostream>

class SomeClass 
{
public:
    void sayHello() 
    {
        std::cout << "Hello!" << std::endl;
    }

    ~SomeClass() 
    {
        std::cout << "~SomeClass" << std::endl;
    }
};

int main() 
{
    std::weak_ptr<SomeClass> wptr;

    {
        auto ptr = std::make_shared<SomeClass>();
        wptr = ptr;

        if(auto tptr = wptr.lock()) 
        {
            tptr->sayHello();
        } 
        else 
        {
            std::cout << "lock() failed" << std::endl;
        }
    }

    if(auto tptr = wptr.lock()) 
    {
        tptr->sayHello();
    }
    else 
    {
        std::cout << "lock() failed" << std::endl;
    }
}

Программа выведет:

Hello!
~SomeClass
lock() failed
Можно думать о weak_ptr как об указателе, позволяющим получить временное владение объектом. Само собой разумеется, если все постоянные указатели на объект перестанут существовать, и останутся только временные, полученные при помощи метода lock() класса weak_ptr, объект продолжит свое существование. Он будет уничтожен только тогда, когда на объект не останется вообще никаких указателей.

3. Умные указатели и наследование
Вопрос, о котором часто забывают — это кастование умных указателей вверх и вниз по иерархии классов. Для shared_ptr в стандартной библиотеке есть шаблоны static_pointer_cast, dynamic_pointer_cast и другие. Для unique_ptr таких же шаблонов почему-то не занесли, но их нетрудно найти на StackOverflow.

Пример кода:

#include <memory>
#include <iostream>

// https://stackoverflow.com/a/21174979/1565238
template<typename Derived, typename Base, typename Del>
std::unique_ptr<Derived, Del> 
static_unique_ptr_cast( std::unique_ptr<Base, Del>&& p )
{
    auto d = static_cast<Derived *>(p.release());
    return std::unique_ptr<Derived, Del>(d,
        std::move(p.get_deleter()));
}

template<typename Derived, typename Base, typename Del>
std::unique_ptr<Derived, Del> 
dynamic_unique_ptr_cast( std::unique_ptr<Base, Del>&& p )
{
    if(Derived *result = dynamic_cast<Derived *>(p.get())) 
    {
        p.release();
        return std::unique_ptr<Derived, Del>(result,
            std::move(p.get_deleter()));
    }
    return std::unique_ptr<Derived, Del>(nullptr, p.get_deleter());
}

class Base 
{
public:
    Base(int num): num(num) {};

    virtual void sayHello() 
    {
        std::cout << "I'm Base #" << num << std::endl;
    }

    virtual ~Base() 
    { 
        std::cout << "~Base #" << num << std::endl;
    }

protected:
    int num;
};

class Derived: public Base 
{
public:
    Derived(int num): Base(num) {}

    virtual void sayHello() 
    {
        std::cout << "I'm Derived #" << num << std::endl;
    }

    virtual ~Derived()
    { 
        std::cout << "~Derived #" << num << std::endl;
    }
};

void testUnique() 
{
    std::cout << "=== testUnique begin ===" << std::endl;

    auto derived = std::make_unique<Derived>(1);
    derived->sayHello();

    std::unique_ptr<Base> base = std::move(derived);
    base->sayHello();

    auto derived2 = static_unique_ptr_cast<Derived>(std::move(base));
    derived2->sayHello();

    std::unique_ptr<Base> base2 = std::make_unique<Derived>(2);
    base2->sayHello();

    std::cout << "=== testUnique end ===" << std::endl;
}

void testShared() 
{
    std::cout << "=== testShared begin ===" << std::endl;

    auto derived = std::make_shared<Derived>(1);
    derived->sayHello();

    auto base = std::static_pointer_cast<Base>(derived);
    base->sayHello();

    auto derived2 = std::static_pointer_cast<Derived>(base);
    derived2->sayHello();

    std::shared_ptr<Base> base2 = std::make_shared<Derived>(2);
    base2->sayHello();

    std::cout << "=== testShared end ===" << std::endl;
}

int main() 
{
    testUnique();
    testShared();
}

Как видите, все оказалось не так уж и сложно.

Заключение
По моим представлениям, приведенной шпаргалки должно хватать в ~99% реальных задач. В оставшемся же 1% случаев вам поможет документация на cppreference.com. Впрочем, я не являюсь гуру C++, и вполне мог о чем-то забыть или чего-то не учесть. Так что, если вы видите в приведенном тексте какие-либо косяки, или вам есть, что к нему добавить, не стесняйтесь воспользоваться комментариями!
