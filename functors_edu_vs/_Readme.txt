Основы указателей для начинающих

На сегодняшний день, ввиду усовершенствования и удешевления технологий, объемы памяти и вычислительной мощности непреклонно растут.

Согласно закону Мура:
Количество транзисторов, размещаемых на кристалле интегральной схемы, удваивается каждые 24 месяца.
Стоит отметить, что изменяются два параметра:

Количество транзисторов
Габариты модуля

Те же принципы проецируются и на объемы оперативной памяти (DRAM).

Сейчас вопрос с памятью не стоит остро, так как объемы памяти за последние 10 лет увеличились в 16 раз на плашку.

Большинство High Level языков программирования (ЯП) уже "из под коробки" скрывают от программиста работу с памятью. И, так как этот вопрос спал, появляется новая каста программистов, которые не понимают или не хотят понимать, как устроена работа с памятью.

В этом топике мы рассмотрим основные моменты работы с памятью на примере языка C++, потому что он является одним из немногих императивных языков, который поддерживает непосредственную работу с памятью и поддерживает ООП.

Для чего же ОНО вообще нужно?

Тут стоит оговориться, данная статья рассчитана на людей, которые только начинают свой путь в C++ или просто хотят иметь представление о динамической памяти.

Во время исполнения любая программа резервирует для себя кусочек памяти в DRAM. Все остальное свободное пространство DRAM называется "Куча"(англ. "Heap"). Выделение памяти во время исполнения под нужды программы происходит именно из кучи и называется выделением динамической памяти.

Вся беда состоит в том, что если не позаботиться об очистке выделенной памяти, когда она больше не нужна, может произойти так называемая "утечка" памяти, при которой ваша система (программа) просто повиснет. Сродни машине, которая заглохла посреди дороги, потому что кто-то забыл ее вовремя заправить.

То, что вы и так должны знать
Большинство современных ЯП укомплектованы сборщиками мусора и очищают память самостоятельно.
Однако C++ зарекомендовал себя, как один из самых быстроисполняемых ЯП отчасти потому, что вся работа с памятью в нем происходит вручную.


new и delete

Выделение памяти может быть статическим и динамическим. Статическим выделением памяти принято называть разовое выделение памяти во время компиляции программы, и объем статической памяти не изменяется во время исполнения. Классическим примером можно привести объявление целочисленной переменной или массива. Но что если программист заранее не знает, сколько потребуется элементов в контейнере?
Использование динамической памяти целесообразно, когда необходимо организовать выделение памяти под нужды программы по мере необходимости.
За выделение динамической памяти в C++ отвечает оператор new, а за ее очистку — delete.
Оператор new возвращает результатом своей работы указатель на новый экземпляр класса.
Синтаксис такой:

|тип данных (Т1) указателя| * |имя указателя|=new |тип T1|;

После оператора new можно использовать конструктор, например, для инициализации полей класса.
Стоит отметить, что та самая утечка памяти случается именно тогда, когда программист теряет контроль над ее выделением.
Важно помнить:
Если вы забыли об очистке динамической памяти от "отработавших" не нужных элементов, то рано или поздно настанет критический момент, когда брать память будет попросту неоткуда.

Пример выделения памяти и ее очистки:
int main{
//Выделяем память, присваивая целочисленному указателю результат работы оператора new
int *ptr = new int();
//Выводим разыменованный указатель
cout<<*ptr<<endl;
//очищаем память, на которую ссылался указатель
delete ptr;
//после оператора delete указатель можно так же использовать, но данных в его ячейке уже не будет

return 0;
}


В этой статье не пойдет речь о так называемых "умных" указателях, так как тема весьма обширна, но, если говорить коротко: "Умные указатели частично автоматизируют процесс очистки памяти за программиста."

Указатели

За работу с динамической памятью в C++ отвечают указатели. Это та тема, от которой у новичков портится аппетит.

Объявить указатель можно с помощью оператора *. По умолчанию он будет указывать на какую-то рандомную область памяти. Чтобы мы могли обращаться к необходимой нам области памяти, нужно передать ссылку (оператор &) на нужную переменную.

Сам по себе указатель — это просто адрес ячейки памяти, и что бы достучаться к данным, которые хранятся в этой ячейке, его необходимо разыменовать.
Важное отступление

Если попытаться вывести указатель без его разыменования, то вместо значения из области памяти, на которую он указывает, выведется адрес этой области памяти.
Для разыменования указателя достаточно поставить оператор * перед его именем.



int main()
{
 //объявляем указатель, который будет содержать в себе ссылку на нашу переменную
    int* pNum= new int(1) ;

    cout<<*pNum<<endl;
 //если инкрементировать не разыменованный указатель, то он будет указывать на соседнюю область памяти, то есть сдвинется на количество байт (которое занимает тип int в данном случае)
    pNum++;
    cout<<*pNum<<endl;
    //таким образом, значение в указателе будет уже не нашей переменной
    return 0;
}



Смотря на такие примеры хочется спросить: "А зачем это вообще нужно, если можно сразу вывести переменную?"

Другой пример:

У нас есть класс Programmers, в котором описаны члены команды программистов, не знающих об указателях.

class Programmers
{
public:
    Programmers(){}
    Programmers(int iWeight, int iAge)
    {
        this->weight = iWeight;
        this->age = iAge;
    }
    int weight;
    int age;
};

int main()
{
    //Массив из указателей на класс Programmers
    int size = 9;
    Programmers *prog [size];
    //Указатель типа Programmers
    Programmers *ptr = nullptr;

    //В цикле создаем объект типа Programmers и присваиваем его адрес нашему указателю
    //а также заполняем наш массив указателей с помощью нашего указателя
    for (int i =0;i<size;i++) 
    {
        ptr=new Programmers(i+100,i);
        prog[i]=ptr;
    }

    return 0;
}

Таким образом, можно манипулировать памятью так, как нам заблагорассудится. И именно поэтому, при работе с памятью можно "выстрелить себе в ногу". Стоит отметить, что работать с указателем гораздо быстрее, так как само значение не копируется, а ему лишь присваивается ссылка на конкретный адрес.

Кстати, столь популярное ключевое слово this предоставляет указатель на текущий объект класса. Повсюду эти указатели.

Пример указателя в повседневной жизни:

Представьте себе ситуацию, когда вы заказываете какое-то блюдо в ресторане. Чтобы сделать заказ, вам достаточно указать на блюдо в меню и вам его приготовят. Точно так же и другие посетители ресторана указывают на нужный пункт в меню. Таким образом, каждая строчка в меню является указателем на функцию приготовления какого-то блюда, и этот указатель был создан на этапе проектирования этого самого меню.

Пример указателя на функцию

//Классические две ничего не возвращающие функции
void Chicken()
{
    cout<<"Wait 5 min...Chicken is cooking"<<endl;
}
void JustWater()
{
    cout<<"Take your water"<<endl;
}

int main()
{
    //объявление указателя на функцию void без параметров
    void (*ptr)();

    ptr = Chicken;
    ptr();
    ptr=JustWater;
    ptr();

    return 0;
}

Вернемся к нашим программистам. Допустим теперь нам нужно вынести поля класса в private секцию, как и подобает принципу инкапсулирования из ООП, тогда нам нужно сделать getter для получения доступа чтения этих полей. Но представим, что полей у нас не 2, а 100, и для этого нужно для каждого писать свой аксессор...

"Спойлер" - Ну конечно нет, я даже не понимаю почему Вы открыли этот спойлер.

Для этого "аксессор" сделаем типа void и передадим в него аргументы по ссылке. Смысл передачи аргумента по ссылке заключается в том, что значение аргумента не копируется, а передается лишь адрес на настоящий аргумент. Таким образом, при изменении значения такого аргумента, изменятся и данные в ячейке памяти настоящего аргумента.
Этотак же влияет на производительность в целом, так как передача аргумента по ссылке быстрее, чем передача по значению. И это еще не говоря про большие коллекции элементов.

К примеру, метод "getParams" внутри изменит входящие аргументы и они изменят свои значения в том числе и в области видимости, откуда он вызывался.
Указатель поможет нам перемещаться по массиву. Из теории о структурах данных мы знаем, что массив — это непрерывная область памяти, элементы которой расположены друг за другом.
Это значит, что при изменении значения указателя на количество байт, которое занимает элемент в массиве, можно достучаться до каждого элемента, пока указатель не выйдет за границы массива.
Создадим еще один указатель, который будет указывать на первый элемент массива программистов.

class Programmers
{
public:
    Programmers(){}
    Programmers(int iWeight, int iAge)
    {
        this->weight = iWeight;
        this->age = iAge;
    }
    //просто принимаем ссылки на переменные, созданные в main и меняем их значения
    void getParams(int &w, int &a)
    {
        w=weight;
        a=age;
    }

private:
    int weight;
    int age;
};

int main()
{
    int size = 9;
    Programmers *prog [size];
    Programmers *ptr=nullptr;

    for (int i =0;i<size;i++) 
    {
        ptr=new Programmers(i+100,i);
        prog[i]=ptr;
    }

    int w,a;
    int count = 9;
//создаем указатель на указатель
//имя массива является указателем на первый его элемент
    Programmers **iter = prog;

    for (int i=0;i<count;i++)
    {
        ptr = *iter++;
        ptr->getParams(w,a);
        if(*(iter-1) != nullptr)
        {
            delete *(iter-1);
            ptr = nullptr;
        }
        cout<<w<<"\t"<<a<<endl;
    }
    return 0;
}



В этом примере я хочу донести до вас суть того, что при изменении значения адреса указателя, можно получить доступ к другой области памяти.

Такие структуры данных как списки, векторы и т.д. основаны на указателях, и поэтому называются динамическими структурами данных. И чтобы итерироваться по ним правильнее использовать итераторы. Итератор представляет собой указатель на элемент структуры данных и предоставляет доступ к элементу контейнера.

В заключение

Разобравшись в теме указателей, работа с памятью становится приятной частью программирования, и в целом появляется детальное понимание, как машина работает с памятью и как ею управлять. В некоем смысле, за самим понятием "Работа с памятью" кроется некая философия. На кончиках пальцев вы изменяете заряд на обкладках пусть и очень маленьких конденсаторов.


